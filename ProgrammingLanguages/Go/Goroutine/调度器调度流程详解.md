# Go 调度器调度流程详解

## 概述

Go 调度器的核心是一个**循环**：不断地选择 Goroutine 执行，处理各种调度事件（阻塞、系统调用、抢占等），然后继续选择下一个 Goroutine。

**核心循环**：

```
schedule (选择G) → execute (执行G) → G运行用户代码 → goexit (G退出) → schedule (选择下一个G)
     ↑                                                                           |
     └───────────────────────────────────────────────────────────────────────────┘
```

---

## 一、调度器的核心组件回顾

### G - M - P 的关系

**整体架构**：

```
                          全局队列 (Global Queue)
                          [G1, G2, G3, ...]
                                   |
                                   | (溢出时放入)
                                   |
            ┌──────────────────────┼──────────────────────┐
            |                      |                      |
            ▼                      ▼                      ▼
    ┌─────────────┐        ┌─────────────┐      ┌─────────────┐
    │     P1      │        │     P2      │      │     P3      │
    │  (处理器)   │        │  (处理器)   │      │  (处理器)   │
    ├─────────────┤        ├─────────────┤      ├─────────────┤
    │ runnext: G* │        │ runnext: G* │      │ runnext: G* │
    │ 本地队列:   │        │ 本地队列:   │      │ 本地队列:   │
    │ [G,G,G...]  │        │ [G,G,G...]  │      │ [G,G,G...]  │
    │ (最多256个) │        │ (最多256个) │      │ (最多256个) │
    └──────┬──────┘        └──────┬──────┘      └──────┬──────┘
           │                      │                    │
           │ (绑定)               │ (绑定)             │ (绑定)
           ▼                      ▼                    ▼
    ┌─────────────┐        ┌─────────────┐      ┌─────────────┐
    │     M1      │        │     M2      │      │     M3      │
    │  (OS线程)   │        │  (OS线程)   │      │  (OS线程)   │
    └─────────────┘        └─────────────┘      └─────────────┘
           │                      │                    │
           ▼                      ▼                    ▼
        执行 G                 执行 G               执行 G
```

**关键规则**：
- M 必须绑定 P 才能执行 G
- P 持有本地 G 队列（最多 256 个）
- P 的数量 = GOMAXPROCS（默认等于 CPU 核心数）

---

## 二、调度循环的核心流程

### 主循环：schedule()

`schedule()` 是调度器的心脏，位于 `runtime/proc.go`。

```go
// 简化版本的 schedule()
func schedule() {
    _g_ := getg()  // 获取当前 g（实际是 g0，调度栈）
    mp := _g_.m    // 获取当前 M

    // 检查是否需要 GC
    if gp := checkGC(); gp != nil {
        execute(gp, false)
        return
    }

top:
    var gp *g

    // 1. 每 61 次调度，从全局队列获取一次
    //    这保证了全局队列的 G 不会饿死
    if _g_.m.p.ptr().schedtick%61 == 0 && sched.runqsize > 0 {
        lock(&sched.lock)
        gp = globrunqget(_g_.m.p.ptr(), 1)
        unlock(&sched.lock)
    }

    // 2. 从 P 的本地队列获取
    if gp == nil {
        gp = runqget(_g_.m.p.ptr())
    }

    // 3. 如果本地队列为空，全局查找
    if gp == nil {
        gp = findRunnable()  // 阻塞调用，直到找到 G
    }

    // 4. 执行选中的 G
    execute(gp, inheritTime)
}
```

### 调度流程图

```
开始 schedule()
     |
     ▼
获取当前 M 和 P
     |
     ▼
需要 GC? ──Yes──> 执行 GC 辅助 ──> 返回
     |
     No
     ▼
schedtick % 61 == 0? ──Yes──> 从全局队列获取 G ──> 获取成功? ──Yes──┐
     |                                                 |            |
     No                                               No            |
     ▼                                                 |            |
检查 P 的 runnext ──有G──> ─────────────────────────────┘            |
     |                                                              |
     无G                                                            |
     ▼                                                              |
从本地队列获取 ──有G──> ────────────────────────────────────────────┘
     |                                                              |
     无G                                                            |
     ▼                                                              |
调用 findRunnable() (阻塞直到找到G) ─────────────────────────────────┘
     |
     ▼
execute(G)
     |
     ▼
G 开始运行
```

---

## 三、获取 Goroutine 的详细流程

### 3.1 从本地队列获取：runqget()

```go
// runtime/proc.go:5956
func runqget(_p_ *p) *g {
    // 1. 优先检查 runnext（下一个优先执行的 G）
    for {
        next := _p_.runnext
        if next == 0 {
            break
        }
        // CAS 操作，保证原子性
        if _p_.runnext.cas(next, 0) {
            return next.ptr()
        }
    }

    // 2. 从本地队列（环形队列）获取
    for {
        h := atomic.LoadAcq(&_p_.runqhead)  // 队列头
        t := _p_.runqtail                   // 队列尾

        if t == h {
            return nil  // 队列为空
        }

        // 从队列头取出 G
        gp := _p_.runq[h%256].ptr()

        // CAS 更新头指针
        if atomic.CasRel(&_p_.runqhead, h, h+1) {
            return gp
        }
    }
}
```

**P 的本地队列（环形队列）**：

```
runq 数组 (大小256):
┌───┬───┬───┬───┬───┬───┬───┬───┬─────┐
│G0 │G1 │G2 │G3 │G4 │G5 │G6 │G7 │ ... │
└───┴───┴───┴─▲─┴───┴───┴─▲─┴───┴─────┘
              │           │
           head=3      tail=7
        (取出位置)   (插入位置)
```

### 3.2 全局查找：findRunnable()

这是最复杂的函数，会尝试多种方式查找可运行的 G。

```go
// runtime/proc.go:2800+
func findRunnable() (gp *g, inheritTime bool) {
    _g_ := getg()
    _p_ := _g_.m.p.ptr()

top:
    // 1. 检查是否需要 STW（Stop The World）
    if sched.gcwaiting != 0 {
        gcstopm()  // 停止当前 M，等待 GC
        goto top
    }

    // 2. 检查定时器
    now, pollUntil, _ := checkTimers(_p_, 0)

    // 3. 尝试从本地队列获取
    if gp := runqget(_p_); gp != nil {
        return gp, false
    }

    // 4. 尝试从全局队列获取
    if sched.runqsize != 0 {
        lock(&sched.lock)
        gp := globrunqget(_p_, 0)
        unlock(&sched.lock)
        if gp != nil {
            return gp, false
        }
    }

    // 5. 检查网络轮询器（netpoller）
    if netpollinited() && atomic.Load(&netpollWaiters) > 0 {
        if list := netpoll(0); !list.empty() {
            gp := list.pop()
            injectglist(&list)
            return gp, false
        }
    }

    // 6. 尝试工作窃取（Work Stealing）
    if gp := stealWork(now); gp != nil {
        return gp, false
    }

    // 7. 再次检查全局队列
    if sched.runqsize != 0 {
        lock(&sched.lock)
        gp := globrunqget(_p_, 0)
        unlock(&sched.lock)
        if gp != nil {
            return gp, false
        }
    }

    // 8. 再次检查网络轮询器（阻塞模式）
    if netpollinited() && atomic.Load(&netpollWaiters) > 0 {
        if list := netpoll(delay); !list.empty() {
            gp := list.pop()
            injectglist(&list)
            return gp, false
        }
    }

    // 9. 所有方法都失败，进入休眠
    stopm()
    goto top
}
```

**查找顺序流程**：

```
findRunnable() 开始
     |
     ▼
步骤1: 检查 GC
     |
需要GC? ──Yes──> 停止M等待 ──> 重新开始
     |
     No
     ▼
步骤2: 从本地队列获取
     |
成功? ──Yes──> 返回 G
     |
     No
     ▼
步骤3: 从全局队列获取
     |
成功? ──Yes──> 返回 G
     |
     No
     ▼
步骤4: 检查网络轮询器(非阻塞)
     |
有就绪的G? ──Yes──> 返回 G
     |
     No
     ▼
步骤5: 工作窃取
     |
窃取成功? ──Yes──> 返回 G
     |
     No
     ▼
步骤6: 再次检查全局队列
     |
成功? ──Yes──> 返回 G
     |
     No
     ▼
步骤7: 网络轮询器(阻塞模式)
     |
有就绪的G? ──Yes──> 返回 G
     |
     No
     ▼
步骤8: 进入休眠
     |
     ▼
M 停止工作，等待被唤醒
     |
     ▼
被唤醒后重新开始
```

### 3.3 工作窃取：stealWork()

```go
// runtime/proc.go:2900+
func stealWork(now int64) *g {
    _p_ := getg().m.p.ptr()

    // 最多尝试 4 次
    for i := 0; i < 4; i++ {
        // 遍历所有 P（随机顺序）
        for enum := stealOrder.start(fastrand()); !enum.done(); enum.next() {
            p2 := allp[enum.position()]

            // 跳过自己
            if _p_ == p2 {
                continue
            }

            // 尝试从 p2 窃取 G
            if gp := runqsteal(_p_, p2); gp != nil {
                return gp  // 窃取成功
            }
        }
    }

    return nil  // 窃取失败
}

// 从 p2 窃取一半的 G
func runqsteal(_p_, p2 *p) *g {
    t := p2.runqtail
    n := t - p2.runqhead

    // 计算要窃取的数量（一半）
    n = n / 2
    if n == 0 {
        return nil
    }

    // 最多窃取 128 个
    if n > 128 {
        n = 128
    }

    // 从 p2 的队列尾部窃取
    h := p2.runqhead
    for i := uint32(0); i < n; i++ {
        gp := p2.runq[(h+i)%256].ptr()
        // 放入 _p_ 的队列
        runqput(_p_, gp, false)
    }

    // 更新 p2 的头指针
    atomic.CasRel(&p2.runqhead, h, h+n)

    // 返回一个 G 立即执行
    return runqget(_p_)
}
```

**窃取示例**：

```
窃取前:
  P1 (当前P，空闲)          P2 (目标P，忙碌)
  本地队列: 空              本地队列: 8个G
                            [G1,G2,G3,G4,G5,G6,G7,G8]
                            head=0, tail=8

     |                            |
     |         执行窃取            |
     ▼                            ▼
  计算窃取数量: n = 8/2 = 4
  从 P2 的 head 开始窃取 4个G

     |                            |
     |                            |
     ▼                            ▼

窃取后:
  P1 获得工作                P2 仍有工作
  本地队列: 4个G            本地队列: 4个G
  [G1,G2,G3,G4]              [G5,G6,G7,G8]
  立即返回 G1 执行           head=4, tail=8
```

---

## 四、执行 Goroutine：execute()

```go
// runtime/proc.go:2700+
func execute(gp *g, inheritTime bool) {
    _g_ := getg()  // 当前 g0
    mp := _g_.m

    // 1. 关联 M 和 G
    mp.curg = gp      // M 当前执行的 G
    gp.m = mp         // G 所在的 M

    // 2. 设置 G 的状态
    casgstatus(gp, _Grunnable, _Grunning)

    // 3. 更新调度统计
    gp.waitsince = 0
    gp.preempt = false
    gp.stackguard0 = gp.stack.lo + _StackGuard

    if !inheritTime {
        mp.p.ptr().schedtick++
    }

    // 4. 切换到 G 的栈执行（汇编实现）
    gogo(&gp.sched)
}
```

### 4.1 栈切换：gogo()

这是汇编代码，位于 `runtime/asm_amd64.s`。

```asm
// func gogo(buf *gobuf)
TEXT runtime·gogo(SB), NOSPLIT, $0-8
    MOVQ    buf+0(FP), BX     // BX = &gp.sched

    // 恢复 G 的寄存器
    MOVQ    gobuf_sp(BX), SP  // 恢复栈指针
    MOVQ    gobuf_bp(BX), BP  // 恢复基址指针
    MOVQ    gobuf_pc(BX), AX  // 恢复程序计数器

    // 跳转到 G 的执行位置
    JMP     AX                // 跳转到 G 的代码
```

**栈切换过程**：

```
切换前 (在 g0 栈):
    SP 指向 g0 栈
    执行 schedule() -> execute() -> gogo()

         |
         ▼

读取 gp.sched 的值:
    1. 读取 SP -> 获取 G 的栈指针
    2. 读取 BP -> 获取 G 的基址指针
    3. 读取 PC -> 获取 G 的程序计数器

         |
         ▼

执行 JMP AX (跳转到G的代码)

         |
         ▼

切换后 (在 G 的栈):
    SP 指向 G 的栈
    PC 指向用户代码
    开始执行用户函数
```

---

## 五、Goroutine 的生命周期

### 5.1 创建 Goroutine

**用户代码**：
```go
go func() {
    fmt.Println("Hello")
}()
```

**编译器转换**：
```go
newproc(size, fn)
```

**创建流程**：

```
用户代码: go func()
     |
     ▼
编译器转换为: runtime.newproc(fn)
     |
     ▼
切换到 g0 栈 (systemstack)
     |
     ▼
newproc1(fn, argp, narg, callerpc)
     |
     ▼
步骤1: 获取或分配 G
     |
     ├─> 尝试从 P 缓存获取 ──成功──> 复用 G
     |                        |
     └─> 失败 ──> 分配新 G (初始栈2KB)
                              |
                              ▼
步骤2: 初始化 G 的栈
     |
     ├─> 计算栈空间
     └─> 复制参数到新栈
                              |
                              ▼
步骤3: 初始化调度信息
     |
     ├─> 设置 SP (栈指针)
     ├─> 设置 PC (程序计数器)
     └─> 设置入口函数
                              |
                              ▼
步骤4: 设置 G 状态
     |
     ├─> 状态: Gdead -> Grunnable
     └─> 分配 goid
                              |
                              ▼
步骤5: 放入队列
     |
     ├─> runqput(_p_, newg, true)  // 优先放入 runnext
     └─> wakep()  // 唤醒或创建 M
                              |
                              ▼
                          完成创建
```

**详细代码**：
```go
// runtime/proc.go:4249
func newproc(siz int32, fn *funcval) {
    argp := add(unsafe.Pointer(&fn), sys.PtrSize)
    gp := getg()
    pc := getcallerpc()

    // 切换到 g0 执行
    systemstack(func() {
        newg := newproc1(fn, argp, siz, gp, pc)

        // 获取当前 P
        _p_ := getg().m.p.ptr()

        // 放入 P 的本地队列
        runqput(_p_, newg, true)

        // 如果有空闲的 P，唤醒或创建 M
        if mainStarted {
            wakep()
        }
    })
}

// runtime/proc.go:4280
func newproc1(fn *funcval, argp unsafe.Pointer, narg int32,
              callergp *g, callerpc uintptr) *g {
    _p_ := getg().m.p.ptr()

    // 1. 尝试从 P 的缓存获取 G
    newg := gfget(_p_)
    if newg == nil {
        // 分配新的 G（初始栈 2KB）
        newg = malg(_StackMin)
        casgstatus(newg, _Gidle, _Gdead)
        allgadd(newg)  // 添加到全局 G 列表
    }

    // 2. 初始化 G 的栈
    totalSize := uintptr(narg)
    totalSize = alignUp(totalSize, sys.PtrSize)

    sp := newg.stack.hi - totalSize
    if narg > 0 {
        // 复制参数到新栈
        memmove(unsafe.Pointer(sp), argp, uintptr(narg))
    }

    // 3. 初始化 G 的调度信息
    memclrNoHeapPointers(unsafe.Pointer(&newg.sched),
                         unsafe.Sizeof(newg.sched))

    newg.sched.sp = sp                    // 栈指针
    newg.sched.pc = abi.FuncPCABI0(goexit) + sys.PCQuantum
    newg.sched.g = guintptr(unsafe.Pointer(newg))

    // 设置 G 的入口函数
    gostartcallfn(&newg.sched, fn)

    // 4. 设置 G 的状态和属性
    newg.gopc = callerpc
    newg.startpc = fn.fn
    casgstatus(newg, _Gdead, _Grunnable)

    // 分配 goid
    if _p_.goidcache == _p_.goidcacheend {
        // 从全局分配一批
        _p_.goidcache = atomic.Xadd64(&sched.goidgen, _GoidCacheBatch)
        _p_.goidcacheend = _p_.goidcache + _GoidCacheBatch
    }
    newg.goid = int64(_p_.goidcache)
    _p_.goidcache++

    return newg
}
```

### 5.2 放入队列：runqput()

```go
// runtime/proc.go:5900
func runqput(_p_ *p, gp *g, next bool) {
    if randomizeScheduler && next && fastrand()%2 == 0 {
        next = false
    }

    // 1. 如果 next=true，放入 runnext（优先执行）
    if next {
    retryNext:
        oldnext := _p_.runnext
        if !_p_.runnext.cas(oldnext, guintptr(unsafe.Pointer(gp))) {
            goto retryNext
        }
        if oldnext == 0 {
            return  // runnext 之前为空，直接返回
        }
        // runnext 之前有 G，将其放入本地队列
        gp = oldnext.ptr()
    }

    // 2. 放入 P 的本地队列
retry:
    h := atomic.LoadAcq(&_p_.runqhead)
    t := _p_.runqtail

    // 检查队列是否已满（256 个）
    if t-h < uint32(len(_p_.runq)) {
        _p_.runq[t%uint32(len(_p_.runq))].set(gp)
        atomic.StoreRel(&_p_.runqtail, t+1)
        return
    }

    // 3. 本地队列已满，放入全局队列
    //    将本地队列的一半 + 新 G 一起放入全局队列
    if runqputslow(_p_, gp, h, t) {
        return
    }
    goto retry
}

// 本地队列满时，将一半放入全局队列
func runqputslow(_p_ *p, gp *g, h, t uint32) bool {
    var batch [len(_p_.runq)/2 + 1]*g

    // 从本地队列取一半
    n := t - h
    n = n / 2
    for i := uint32(0); i < n; i++ {
        batch[i] = _p_.runq[(h+i)%uint32(len(_p_.runq))].ptr()
    }
    if !atomic.CasRel(&_p_.runqhead, h, h+n) {
        return false
    }

    // 加上新的 G
    batch[n] = gp

    // 随机打乱（提升公平性）
    if randomizeScheduler {
        for i := uint32(1); i <= n; i++ {
            j := fastrandn(i + 1)
            batch[i], batch[j] = batch[j], batch[i]
        }
    }

    // 放入全局队列
    lock(&sched.lock)
    globrunqputbatch(&batch[0], int32(n+1))
    unlock(&sched.lock)

    return true
}
```

**队列状态变化**：

```
初始状态:
  P 本地队列已满
  256个G: [G1, G2, G3, ..., G256]
  head=0, tail=256

     |
     ▼
新创建 Gnew
     |
     ▼
尝试放入本地队列 -> 发现已满 -> 触发 runqputslow()
     |
     ▼
执行 runqputslow:
  1. 取出前一半(128个): G1..G128
  2. 加上新G: 总共129个
  3. 放入全局队列
     |
     ▼
结果状态:
  P 本地队列:
    剩余128个: [G129, G130, ..., G256]
    head=128, tail=256

  全局队列:
    新增129个: [G1, G2, ..., G128, Gnew]
```

---

## 六、各种调度场景

### 6.1 场景 1：Channel 阻塞

**用户代码**：
```go
ch := make(chan int)
val := <-ch  // 阻塞在这里
```

**Channel 阻塞流程**：

```
用户代码: val = <-ch
     |
     ▼
runtime.chanrecv1(ch, &val)
     |
     ▼
runtime.chanrecv(ch, ep, block=true)
     |
     ▼
检查 channel 是否有数据可读?
     |
     ├─> Yes: 直接读取返回
     |
     └─> No: 进入阻塞流程
              |
              ▼
          创建 sudog 结构
              |
              ▼
          将当前 G 加入 channel 接收队列
              |
              ▼
          调用 gopark(chanparkcommit, ...)
              |
              ▼
          设置 park 状态
              |
              ▼
          mcall(park_m)  // 切换到 g0 栈
              |
              ▼
          park_m(gp):
            步骤1: 设置 G 状态为 Gwaiting
            步骤2: 解除 M 和 G 绑定 (dropg)
            步骤3: 释放 channel 锁
            步骤4: 调用 schedule()
              |
              ▼
          重新开始调度循环，选择其他 G 执行
```

**被唤醒流程**：

```
发送方: ch <- value
     |
     ▼
runtime.chansend(ch, &value, block=true)
     |
     ▼
检查接收等待队列
     |
有等待的 G?
     |
     Yes
     ▼
从 c.recvq 取出等待的 G
     |
     ▼
直接传递数据给 G
     |
     ▼
调用 goready(gp)
     |
     ▼
设置 G 状态: Gwaiting -> Grunnable
     |
     ▼
runqput(_p_, gp, true)  // 放入 runnext 优先执行
     |
     ▼
G 等待被调度
     |
     ▼
稍后被 schedule() 选中
     |
     ▼
execute(G)
     |
     ▼
G 继续执行（从 <-ch 返回）
```

**详细代码**：
```go
// runtime/chan.go
func chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool) {
    // ... 尝试接收 ...

    if !block {
        return false, false
    }

    // 阻塞接收
    gp := getg()
    mysg := acquireSudog()
    mysg.g = gp
    mysg.c = c

    // 将当前 G 加入 channel 的等待队列
    c.recvq.enqueue(mysg)

    // 让出 CPU，进入等待状态
    gopark(chanparkcommit, unsafe.Pointer(&c.lock),
           waitReasonChanReceive, traceEvGoBlockRecv, 2)

    // ... 被唤醒后继续执行 ...
}

// runtime/proc.go:345
func gopark(unlockf func(*g, unsafe.Pointer) bool, lock unsafe.Pointer,
            reason waitReason, traceEv byte, traceskip int) {
    mp := acquirem()
    gp := mp.curg

    // 设置 park 状态
    mp.waitlock = lock
    mp.waitunlockf = unlockf
    gp.waitreason = reason

    // 切换到 g0 执行 park_m
    mcall(park_m)
}

// runtime/proc.go:3100
func park_m(gp *g) {
    _g_ := getg()

    // 1. 设置 G 的状态为等待
    casgstatus(gp, _Grunning, _Gwaiting)

    // 2. 解除 M 和 G 的绑定
    dropg()

    // 3. 执行 unlock 函数（如果有）
    if fn := _g_.m.waitunlockf; fn != nil {
        fn(gp, _g_.m.waitlock)
        _g_.m.waitunlockf = nil
        _g_.m.waitlock = nil
    }

    // 4. 重新开始调度循环
    schedule()
}
```

### 6.2 场景 2：系统调用（Syscall）

**用户代码**：
```go
file.Read(buf)  // 系统调用
```

**系统调用流程**：

```
时间线视图:

用户代码                G1              M1              P1          Sysmon         M2          内核
   |                    |               |               |             |             |           |
   |-file.Read(buf)---->|               |               |             |             |           |
   |                    |               |               |             |             |           |
   |                    |-syscall.Read->|               |             |             |           |
   |                    |               |               |             |             |           |
   |                    |               |-entersyscall->|             |             |           |
   |                    |               | 保存 G 状态   |             |             |           |
   |                    |(Gsyscall)     | G: Gsyscall   |             |             |           |
   |                    |               |               |             |             |           |
   |                    |               |-P.m = 0------>|             |             |           |
   |                    |               |               |(Psyscall)   |             |           |
   |                    |               |               | P不再绑定M  |             |           |
   |                    |               |               |             |             |           |
   |                    |               |---进入内核态---------------->|------------>|           |
   |                    |               |(阻塞等待I/O)  |             |             |           |
   |                    |               |               |             |             |           |
   |                    |               |               |<--定期检查--|             |           |
   |                    |               |               | 发现P1长时间|             |           |
   |                    |               |               | 在Psyscall  |             |           |
   |                    |               |               |             |             |           |
   |                    |               |               |<-Psyscall->Pidle          |           |
   |                    |               |               |             |             |           |
   |                    |               |               |<--handoffp(P1)----------->|           |
   |                    |               |               |             | 创建/唤醒M2 |           |
   |                    |               |               |<--绑定 P1---+-------------|           |
   |                    |               |               |             |             |           |
   |                    |               |               | P1执行G2<-----------------|           |
   |                    |               |               |             |             |           |
   |                    |               |<--系统调用返回--------------+-------------|           |
   |                    |               |               |             |             |           |
   |                    |               |-exitsyscall-->|             |             |           |
   |                    |               |               |             |             |           |
   |                    |               |-尝试重新获取P1>| P1已被M2占用|             |           |
   |                    |               |               |             |             |           |
   |                    |               |-尝试获取空闲P |             |             |           |
   |                    |               | 没有空闲P     |             |             |           |
   |                    |               |               |             |             |           |
   |                    |(Grunnable)    |               |             |             |           |
   |                    |-----------放入全局队列-------->|             |             |           |
   |                    |               |               |             |             |           |
   |                    |               |-M1进入休眠    |             |             |           |
   |                    |               |               |             |             |           |
```

**详细代码**：
```go
// runtime/proc.go:3600
func entersyscall() {
    _g_ := getg()

    // 1. 保存当前状态（PC, SP 等）
    save(getcallerpc(), getcallersp())

    // 2. 设置 P 的状态
    _g_.m.locks++
    _g_.syscallsp = _g_.sched.sp
    _g_.syscallpc = _g_.sched.pc
    casgstatus(_g_, _Grunning, _Gsyscall)

    // 3. 标记 P 进入 syscall
    _p_ := _g_.m.p.ptr()
    _p_.m = 0  // P 不再绑定 M
    atomic.Store(&_p_.status, _Psyscall)

    // 4. 记录时间（用于 sysmon 检测）
    _g_.m.syscalltick = _g_.m.p.ptr().syscalltick
    _g_.m.locks--
}

// runtime/proc.go:3700
func exitsyscall() {
    _g_ := getg()

    // 1. 快速路径：尝试重新获取原来的 P
    if exitsyscallfast(oldp) {
        // 成功获取，继续执行
        casgstatus(_g_, _Gsyscall, _Grunning)
        return
    }

    // 2. 慢路径：P 已被占用
    mcall(exitsyscall0)
}

func exitsyscall0(gp *g) {
    _g_ := getg()

    casgstatus(gp, _Gsyscall, _Grunnable)

    // 解除 M 和 G 的绑定
    dropg()

    // 尝试获取任何空闲的 P
    _p_ := pidleget()
    if _p_ == nil {
        // 没有空闲 P，将 G 放入全局队列
        lock(&sched.lock)
        globrunqput(gp)
        unlock(&sched.lock)

        // M 进入休眠
        stopm()
        // 被唤醒后重新调度
        schedule()
        return
    }

    // 获取到 P，继续执行
    acquirep(_p_)
    execute(gp, false)
}
```

**Sysmon 的 P 转移**：
```go
// runtime/proc.go:5000+
func sysmon() {
    for {
        usleep(delay)

        // 遍历所有 P
        for _, _p_ := range allp {
            if _p_.status == _Psyscall {
                // 检查是否超时（通常 10ms）
                if runqempty(_p_) && atomic.Load(&sched.nmspinning)+
                   atomic.Load(&sched.npidle) > 0 {
                    // P 的队列为空且有其他空闲资源，跳过
                    continue
                }

                // P 转移：从当前 M 转移到其他 M
                if atomic.Cas(&_p_.status, _Psyscall, _Pidle) {
                    _p_.syscalltick++
                    handoffp(_p_)
                }
            }
        }
    }
}

func handoffp(_p_ *p) {
    // 如果 P 有工作，启动新的 M
    if !runqempty(_p_) || sched.runqsize != 0 {
        startm(_p_, false)
        return
    }

    // P 没有工作，放入空闲队列
    pidleput(_p_)
}
```

**系统调用状态变化**：

```
系统调用前:
┌─────────────────────────────┐
│ M1 绑定 P1                  │
│ P1 绑定 G1 正在运行          │
│ P1 本地队列: [G2, G3, G4]   │
└─────────────────────────────┘

         |
         | G1 调用 file.Read()
         ▼

进入 syscall (entersyscall):
┌─────────────────────────────┐
│ M1: 阻塞，G1 在系统调用中    │
│ P1: 状态 Psyscall           │
│     等待被转移              │
│     本地队列: [G2, G3, G4]  │
└─────────────────────────────┘

         |
         | 超过 10ms
         ▼

Sysmon 检测:
┌─────────────────────────────┐
│ M1: 仍在系统调用中           │
│ P1: Psyscall -> Pidle       │
│     handoffp(P1)            │
│     创建/唤醒 M2             │
│ M2: 绑定 P1，执行 G2         │
│ P1 本地队列: [G3, G4]       │
└─────────────────────────────┘

         |
         | syscall 完成
         ▼

系统调用返回 (exitsyscall):
┌─────────────────────────────┐
│ M1: 尝试获取 P              │
│   - P1 已被 M2 占用          │
│   - 无空闲 P                │
│                             │
│ G1: 放入全局队列             │
│ M1: 进入休眠，等待被唤醒     │
└─────────────────────────────┘
```

### 6.3 场景 3：抢占调度

**触发条件**：G 运行超过 10ms

**抢占调度流程**：

```
Sysmon 定期检查 (每10ms)
     |
     ▼
遍历所有 P
     |
     ▼
检查 P 状态
     |
P 状态为 Prunning?
     |
     Yes
     ▼
计算运行时间
     |
运行时间 > 10ms?
     |
     Yes
     ▼
触发抢占: preemptone(_p_)
     |
     ▼
步骤1: 获取 P 当前运行的 G
     |
     ▼
步骤2: 设置抢占标记
     gp.preempt = true
     gp.stackguard0 = stackPreempt
     |
     ▼
步骤3: 请求异步抢占
     preemptM(M)
     |
     ▼
设置信号标志 (原子操作)
     |
     ▼
signalM(M, SIGURG)
向 M 的底层线程发送信号
     |
     ▼
M 收到信号
     |
     ▼
操作系统中断当前执行
     |
     ▼
跳转到信号处理函数 (sighandler)
     |
     ▼
doSigPreempt(gp, ctxt)
     |
     ▼
检查是否可以安全抢占?
     |
     Yes
     ▼
设置返回地址到 asyncPreempt
     |
     ▼
设置抢占标记
     |
     ▼
执行 asyncPreempt (汇编):
  - 保存所有通用寄存器 (BP, BX, R12-R15)
  - 保存所有浮点寄存器 (X0-X15)
     |
     ▼
调用 asyncPreempt2()
     |
     ▼
切换到 g0 执行: mcall(gopreempt_m)
     |
     ▼
gopreempt_m(gp):
  步骤1: 设置 G 状态为 Grunnable
  步骤2: 解除 M 和 G 绑定
  步骤3: 将 G 放回队列 (runqput)
  步骤4: 重新调度 (schedule)
     |
     ▼
选择下一个 G 执行
```

**详细代码**：
```go
// runtime/proc.go:5100
func preemptone(_p_ *p) bool {
    mp := _p_.m.ptr()
    if mp == nil {
        return false
    }

    gp := mp.curg
    if gp == nil {
        return false
    }

    // 设置抢占标记
    gp.preempt = true
    gp.stackguard0 = stackPreempt

    // 请求异步抢占（Go 1.14+）
    preemptM(mp)

    return true
}

func preemptM(mp *m) {
    // 设置信号标志（原子操作）
    if atomic.Cas(&mp.signalPending, 0, 1) {
        // 发送 SIGURG 信号
        signalM(mp, sigPreempt)
    }
}

// runtime/signal_unix.go
func doSigPreempt(gp *g, ctxt *sigctxt) {
    // 检查是否可以安全抢占
    if wantAsyncPreempt(gp) {
        if ok, newpc := isAsyncSafePoint(gp, ctxt.sigpc(), ctxt.sigsp()); ok {
            // 设置返回地址到 asyncPreempt
            ctxt.pushCall(abi.FuncPCABI0(asyncPreempt), newpc)
        }
    }

    // 设置抢占标记
    atomic.Xadd(&gp.m.preemptGen, 1)
    atomic.Store(&gp.m.signalPending, 0)
}
```

**asyncPreempt（汇编）**：
```asm
// runtime/preempt_amd64.s
TEXT ·asyncPreempt(SB),NOSPLIT|NOFRAME,$0-0
    // 保存所有通用寄存器
    PUSHQ BP
    PUSHQ BX
    PUSHQ R12
    PUSHQ R13
    PUSHQ R14
    PUSHQ R15

    // 分配栈空间保存浮点寄存器
    ADJSP $288
    MOVUPS X0, 0(SP)
    MOVUPS X1, 16(SP)
    // ... 保存 X0-X15

    // 调用 Go 函数处理抢占
    CALL ·asyncPreempt2(SB)

    // 恢复所有寄存器
    MOVUPS 0(SP), X0
    MOVUPS 16(SP), X1
    // ... 恢复 X0-X15
    ADJSP $-288

    POPQ R15
    POPQ R14
    POPQ R13
    POPQ R12
    POPQ BX
    POPQ BP

    RET
```

```go
// runtime/preempt.go
func asyncPreempt2() {
    gp := getg()

    // 切换到 g0 执行
    mcall(gopreempt_m)
}

func gopreempt_m(gp *g) {
    _g_ := getg()

    // 1. G 状态改为 Runnable
    casgstatus(gp, _Grunning, _Grunnable)

    // 2. 解除 M 和 G 的绑定
    dropg()

    // 3. 将 G 放回队列
    runqput(_g_.m.p.ptr(), gp, false)

    // 4. 重新调度
    schedule()
}
```

### 6.4 场景 4：Goroutine 退出

**用户代码**：
```go
go func() {
    fmt.Println("Hello")
    // 函数返回
}()
```

**Goroutine 退出流程**：

```
用户函数执行完毕
     |
     ▼
函数返回
     |
     ▼
跳转到 goexit (编译器插入)
     |
     ▼
goexit1()
     |
     ▼
mcall(goexit0)
切换到 g0 栈
     |
     ▼
goexit0(gp):
     |
     ▼
步骤1: 设置 G 状态为 Gdead
     |
     ▼
步骤2: 清理 G 的数据
     ├─> gp.m = nil
     ├─> gp.lockedm = 0
     ├─> gp.preempt = false
     ├─> gp.param = nil
     └─> ... 等等
     |
     ▼
步骤3: 解除 M 和 G 绑定
     dropg()
     |
     ▼
步骤4: 将 G 放入 P 空闲列表
     gfput(_p_, gp)
     |
     ▼
检查栈大小
     |
     ├─> 栈大小 = 2KB: 保留栈，放入缓存
     └─> 栈大小 != 2KB: 释放栈
     |
     ▼
添加到 P 的空闲列表
     |
     ▼
缓存数量 >= 64?
     |
     ├─> Yes: 转移一半(32个)到全局空闲列表
     └─> No: 直接完成
     |
     ▼
步骤5: 继续调度循环
     schedule()
     |
     ▼
选择下一个 G 执行
```

**详细代码**：
```go
// runtime/proc.go:3500
func goexit1() {
    mcall(goexit0)
}

// runtime/proc.go:3400
func goexit0(gp *g) {
    _g_ := getg()
    _p_ := _g_.m.p.ptr()

    // 1. 设置 G 的状态为 Dead
    casgstatus(gp, _Grunning, _Gdead)

    // 2. 清理 G 的数据
    gp.m = nil
    gp.lockedm = 0
    gp.preempt = false
    gp.paniconfault = false
    gp.param = nil
    gp.labels = nil
    gp.timer = nil

    // 3. 解除 M 和 G 的绑定
    dropg()

    // 4. 将 G 放入 P 的空闲列表（复用）
    gfput(_p_, gp)

    // 5. 继续调度循环
    schedule()
}

// 将 G 放入 P 的空闲列表
func gfput(_p_ *p, gp *g) {
    stksize := gp.stack.hi - gp.stack.lo

    // 只缓存栈大小为 2KB 的 G
    if stksize != _FixedStack {
        stackfree(gp.stack)
        gp.stack.lo = 0
        gp.stack.hi = 0
        gp.stackguard0 = 0
    }

    // 添加到 P 的空闲列表
    gp.schedlink = _p_.gFree.ptr()
    _p_.gFree.set(gp)
    _p_.gFree.n++

    // 如果缓存太多，释放一些到全局
    if _p_.gFree.n >= 64 {
        lock(&sched.gFree.lock)
        // 转移一半到全局
        for _p_.gFree.n >= 32 {
            gp = _p_.gFree.ptr()
            _p_.gFree = gp.schedlink
            _p_.gFree.n--

            gp.schedlink = sched.gFree.list
            sched.gFree.list = gp
            sched.gFree.n++
        }
        unlock(&sched.gFree.lock)
    }
}
```

---

## 七、特殊线程：Sysmon

### 7.1 Sysmon 的作用

Sysmon 是一个特殊的监控线程：
- 不需要 P 就能运行
- 定期检查系统状态
- 触发抢占、回收等操作

```go
// runtime/proc.go:4800
func sysmon() {
    lock(&sched.lock)
    sched.nmsys++
    checkdead()  // 检查死锁
    unlock(&sched.lock)

    lasttrace := int64(0)
    idle := 0
    delay := uint32(0)

    // 主循环
    for {
        // 动态调整检查频率
        if idle == 0 {
            delay = 20  // 20 微秒
        } else if idle > 50 {
            delay *= 2
        }
        if delay > 10*1000 {
            delay = 10 * 1000  // 最多 10 毫秒
        }
        usleep(delay)

        // 1. 检查是否需要强制 GC
        if t := (gcTrigger{kind: gcTriggerTime, now: now}); t.test() {
            lock(&sched.lock)
            if atomic.Load(&forcegc.idle) != 0 {
                forcegc.idle = 0
                forcegc.g.schedlink = 0
                injectglist(&forcegc.g)
            }
            unlock(&sched.lock)
        }

        // 2. 抢占长时间运行的 G
        if retake(now) != 0 {
            idle = 0
        } else {
            idle++
        }

        // 3. 检查定时器
        if checkTimers {
            timeSleepUntil := checkTimers(now, pollUntil)
        }

        // 4. 回收长时间 idle 的 P
        if netpollinited() && lastpoll != 0 {
            if delta := now - lastpoll; delta > 10*1000*1000 {
                atomic.Cas64(&sched.lastpoll, lastpoll, now)
                list := netpoll(0)
                if !list.empty() {
                    incidlelocked(-1)
                    injectglist(&list)
                    incidlelocked(1)
                }
            }
        }
    }
}
```

### 7.2 抢占检查：retake()

```go
// runtime/proc.go:5000
func retake(now int64) uint32 {
    n := 0

    // 遍历所有 P
    for i := 0; i < len(allp); i++ {
        _p_ := allp[i]
        pd := &_p_.sysmontick
        s := _p_.status

        if s == _Prunning || s == _Psyscall {
            // 计算 P 运行的时间
            t := now - pd.schedwhen
            if t > 10*1000*1000 {  // 10 毫秒
                // P 运行超过 10ms
                if s == _Prunning {
                    // 抢占正在运行的 G
                    if preemptone(_p_) {
                        n++
                    }
                } else if s == _Psyscall {
                    // 转移 syscall 中的 P
                    if atomic.Cas(&_p_.status, _Psyscall, _Pidle) {
                        n++
                        _p_.syscalltick++
                        handoffp(_p_)
                    }
                }
            }
        }
    }

    return uint32(n)
}
```

**Sysmon 工作流程**：

```
Sysmon 主循环开始
     |
     ▼
步骤1: 动态调整检查频率
     |
系统繁忙? ──Yes──> delay = 20 微秒
     |
     No
     ▼
逐渐增加 delay (最多10毫秒)
     |
     ▼
步骤2: 休眠 delay 时间
     usleep(delay)
     |
     ▼
步骤3: 检查强制 GC
     |
距离上次GC超过2分钟? ──Yes──> 注入强制GC的Goroutine
     |
     No
     ▼
步骤4: 抢占检查
     retake(now)
     |
     ▼
遍历所有 P
     |
     ▼
P状态为Prunning? ──Yes──> 运行时间>10ms? ──Yes──> 抢占当前G
     |                              |
     No                             No
     ▼                              |
P状态为Psyscall? ──Yes──> syscall时间>10ms? ──Yes──> 转移P给其他M
     |                    且P队列不为空?
     No                             |
     ▼                              No
     |                              |
     └──────────────────────────────┘
                   |
                   ▼
步骤5: 检查定时器
     |
     ▼
处理到期的定时器
     |
     ▼
步骤6: 网络轮询
     |
有网络I/O就绪的G? ──Yes──> 注入到调度器
     |
     No
     ▼
循环继续
```

---

## 八、完整流程图

### 8.1 正常执行流程

```
程序启动
     |
     ▼
创建主 Goroutine
     |
     ▼
初始化调度器
     |
     ▼
启动 Sysmon 监控线程
     |
     ▼
进入调度循环: schedule()
     |
     ▼
检查 GC 和定时器
     |
     ▼
选择 G:
  - 方式1: 每61次从全局队列
  - 方式2: 从本地队列 (runnext/runq)
  - 方式3: findRunnable (全局查找)
     |
     ▼
execute(G)
     |
     ▼
关联 M 和 G
     |
     ▼
设置 G 状态为 Grunning
     |
     ▼
gogo(&gp.sched)
切换到 G 的栈
     |
     ▼
G 执行用户代码
     |
     ▼
可能的路径:
     |
     ├─> 路径1: 正常退出
     |      |
     |      ├─> goexit
     |      ├─> 清理 G
     |      ├─> 回收 G (放入空闲列表)
     |      └─> schedule() (重新调度)
     |
     ├─> 路径2: 阻塞 (channel, mutex等)
     |      |
     |      ├─> gopark
     |      ├─> 设置 G 为 Gwaiting
     |      ├─> dropg (解除M和G绑定)
     |      └─> schedule() (重新调度)
     |
     ├─> 路径3: 系统调用
     |      |
     |      ├─> entersyscall
     |      ├─> P/M 分离
     |      ├─> P 可能被转移
     |      ├─> exitsyscall
     |      ├─> 重新获取P 或 进入全局队列
     |      └─> schedule() (重新调度)
     |
     ├─> 路径4: 被抢占
     |      |
     |      ├─> asyncPreempt
     |      ├─> 保存状态
     |      ├─> 放回队列
     |      └─> schedule() (重新调度)
     |
     └─> 路径5: panic
            |
            ├─> panic 处理
            ├─> recover? ──Yes──> schedule()
            └─> No ──> 程序终止
```

### 8.2 多 P 并行执行时间线

```
时间线 (单位: 毫秒)

时间:     0ms    100ms   200ms   300ms   400ms   500ms
         |       |       |       |       |       |
P1/M1:   [--G1--][--G2--][syscall阻塞---][新M4-][--G3--]
                           (M1阻塞)       获取P1

P2/M2:   [--G4--][空闲窃取][窃取G5-][--G6--][--G7--]
                  (50ms)

P3/M3:   [--G8--][--G9--][G9][--G10------][--G11--]
                        被抢占
                        (20ms)

全局队列: [G12,G13] ... [接收溢出] ... [定期取出]

Sysmon:  [检查][抢占G9][转移P1][检查]
          0ms   200ms   300ms   400ms
```

**说明**：
- P1 在 200ms 时 G2 进行系统调用，M1 阻塞
- Sysmon 在 300ms 检测到 P1 长时间 syscall，将 P1 转移给新的 M4
- P2 在 100ms 空闲，进行工作窃取，从其他 P 获取 G5
- P3 在 200ms 时 G9 被 Sysmon 抢占（运行超过10ms）

---

## 九、性能优化要点

### 9.1 本地队列优先

**优先级顺序**：

```
获取 G 的优先级:

优先级1: runnext
  特点: 无竞争，直接 CAS 获取
  性能: 最快

     ↓ (如果 runnext 为空)

优先级2: 本地队列 (P.runq)
  特点: 无锁，仅本地访问
  性能: 快速

     ↓ (如果本地队列为空)

优先级3: 全局队列 (每61次)
  特点: 有锁，全局竞争
  性能: 中等

     ↓ (如果全局队列为空)

优先级4: 工作窃取
  特点: 有锁，遍历其他P
  性能: 较慢

     ↓ (如果窃取失败)

优先级5: 网络轮询器
  特点: 阻塞I/O等待
  性能: 最慢
```

**为什么有效？**
- 缓存局部性：G 倾向在同一个 P/M 执行
- 减少锁竞争：大部分操作无需全局锁
- 负载均衡：工作窃取兜底

### 9.2 避免频繁创建 Goroutine

**不好的做法**：
```go
for i := 0; i < 1000000; i++ {
    go func() {
        // 短任务
    }()
}
```

**更好的做法**：
```go
// Worker Pool 模式
func worker(jobs <-chan Job) {
    for job := range jobs {
        job.Do()
    }
}

// 创建固定数量的 Worker
for i := 0; i < numWorkers; i++ {
    go worker(jobs)
}
```

### 9.3 避免 Goroutine 泄漏

**常见问题**：
```go
// 泄漏示例
func leak() {
    ch := make(chan int)

    go func() {
        val := <-ch  // 永远阻塞
        fmt.Println(val)
    }()

    // 忘记发送数据，Goroutine 永远不会退出
}
```

**正确做法**：
```go
func noLeak() {
    ch := make(chan int)
    done := make(chan struct{})

    go func() {
        defer close(done)
        select {
        case val := <-ch:
            fmt.Println(val)
        case <-time.After(time.Second):
            return  // 超时退出
        }
    }()

    // 确保 Goroutine 能退出
}
```

---

## 十、调试和观测

### 10.1 查看调度器状态

```bash
# 设置环境变量
GODEBUG=schedtrace=1000 ./program

# 输出示例：
SCHED 1000ms: gomaxprocs=4 idleprocs=0 threads=6 spinningthreads=1
  idlethreads=0 runqueue=0 [2 0 1 0]
```

**字段说明**：
- `gomaxprocs=4`: 4 个 P
- `idleprocs=0`: 0 个空闲 P（所有 P 都在工作）
- `threads=6`: 6 个 M
- `spinningthreads=1`: 1 个 M 正在自旋寻找工作
- `runqueue=0`: 全局队列长度为 0
- `[2 0 1 0]`: 各 P 的本地队列长度

### 10.2 查看详细信息

```bash
GODEBUG=schedtrace=1000,scheddetail=1 ./program
```

### 10.3 使用 pprof

```go
import _ "net/http/pprof"

go func() {
    http.ListenAndServe("localhost:6060", nil)
}()
```

访问：
- `http://localhost:6060/debug/pprof/goroutine?debug=2` - 查看所有 Goroutine
- `http://localhost:6060/debug/pprof/heap` - 内存分配
- `http://localhost:6060/debug/pprof/profile` - CPU profile

### 10.4 使用 trace

```go
import "runtime/trace"

f, _ := os.Create("trace.out")
trace.Start(f)
defer trace.Stop()

// 程序代码
```

分析：
```bash
go tool trace trace.out
```

---

## 十一、总结

### 调度器的核心设计

**三个关键组件**：

```
    G (Goroutine)          M (Machine/OS线程)        P (Processor)
    执行单元                 执行者                   执行上下文
         |                       |                         |
         |                       |                         |
         └───────────────────────┴─────────────────────────┘
                                 |
                        M 必须绑定 P 才能执行 G
```

**调度循环**：

```
schedule() ──> findRunnable() ──> execute() ──> gogo() ──> [用户代码] ──> schedule()
    ▲                                                                         |
    |                                                                         |
    └─────────────────────────────────────────────────────────────────────────┘
```

**查找策略**：

```
查找 G
  |
  ├─> 本地优先 (runnext + 本地队列) - 快速无锁
  |
  ├─> 全局兜底 (每61次) - 保证公平
  |
  ├─> 工作窃取 - 负载均衡
  |
  ├─> 网络轮询 - I/O就绪
  |
  └─> 休眠 - 等待唤醒
```

### 核心优化

1. **无锁设计**：本地队列无锁访问
2. **缓存友好**：G 倾向在同一 P 执行
3. **负载均衡**：工作窃取算法
4. **快速切换**：用户态切换，约200ns
5. **抢占保证**：10ms 强制抢占

### 关键流程

| 场景 | 入口函数 | 核心操作 | 结果 |
|------|---------|---------|------|
| 创建 G | newproc | 分配 G -> 初始化 -> 入队 | G 进入队列 |
| 阻塞 | gopark | 设置等待状态 -> dropg -> schedule | M 执行其他 G |
| 系统调用 | entersyscall | P/M分离 -> P转移 | P 继续工作 |
| 抢占 | preemptone | 发信号 -> 保存状态 -> 重调度 | 公平调度 |
| 退出 | goexit | 清理 G -> 回收 -> schedule | G 被复用 |

**最重要的启示**：
> Go 调度器通过**分层设计**（G-M-P）和**局部优先**策略，实现了高效、可扩展的并发调度，这是 Go 能够轻松支持百万级 Goroutine 的关键。

---

## 参考源码位置

核心文件：
- runtime/proc.go - 调度核心（schedule, execute, findRunnable）
- runtime/runtime2.go - 数据结构定义（g, m, p）
- runtime/asm_*.s - 汇编实现（gogo, mcall）
- runtime/chan.go - Channel 实现（gopark, goready）
- runtime/netpoll.go - 网络轮询器
- runtime/preempt.go - 抢占实现

**关键函数行号**（Go 1.21）：
- `schedule()`: proc.go:3300
- `findRunnable()`: proc.go:2800
- `execute()`: proc.go:2700
- `newproc()`: proc.go:4249
- `gopark()`: proc.go:345
- `entersyscall()`: proc.go:3600
- `sysmon()`: proc.go:4800
