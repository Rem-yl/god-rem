# 进程与线程详解

## 核心区别

| 维度 | 进程 (Process) | 线程 (Thread) |
|------|---------------|---------------|
| **定义** | 资源分配的基本单位 | CPU调度的基本单位 |
| **作用** | 资源容器（工厂） | 执行单元（工人） |
| **CPU执行** | 不直接执行 | 直接执行 |
| **内存空间** | 独立的地址空间 | 共享进程地址空间 |
| **通信方式** | IPC（管道、消息队列、共享内存） | 直接访问共享内存 |
| **创建开销** | 大（需分配独立资源） | 小（只需分配栈和寄存器） |
| **切换开销** | 大（需切换地址空间） | 小（同进程内无需切换地址空间） |
| **崩溃影响** | 独立，不影响其他进程 | 会导致整个进程崩溃 |

## 数据结构

### 进程控制块 (PCB - Process Control Block)

进程控制块包含进程的所有管理信息：

```
PCB 结构：
├─ 进程标识信息
│  ├─ 进程ID (PID)
│  ├─ 父进程ID (PPID)
│  └─ 用户ID (UID)
│
├─ 处理器状态信息（早期进程模型包含，引入线程后移到TCB）
│  ├─ 程序计数器 (PC) - 下一条要执行的指令地址
│  ├─ 寄存器组 - CPU 各寄存器的值
│  └─ 栈指针 (SP) - 当前栈顶位置
│
├─ 进程调度信息
│  ├─ 进程状态 (就绪/运行/阻塞/终止)
│  ├─ 优先级
│  ├─ 调度队列指针
│  └─ CPU时间统计
│
├─ 内存管理信息
│  ├─ 页表基址 (或段表)
│  ├─ 代码段地址和大小
│  ├─ 数据段地址和大小
│  ├─ 堆的起始和当前位置
│  └─ 栈的起始和限制
│
└─ 资源管理信息
   ├─ 打开的文件描述符表
   ├─ 工作目录
   ├─ 信号处理表
   └─ 其他I/O资源
```

**关键点**：
- PCB 是进程在操作系统中的"身份证"
- 包含所有资源和环境信息
- 早期只有进程时，执行状态也在 PCB 中
- 引入线程后，执行相关信息移到了 TCB

### 线程控制块 (TCB - Thread Control Block)

线程控制块只包含执行相关信息：

```
TCB 结构：
├─ 线程标识信息
│  ├─ 线程ID (TID)
│  └─ 所属进程ID (PID)
│
├─ 处理器状态信息（线程独有）
│  ├─ 程序计数器 (PC) - 当前执行位置
│  ├─ 寄存器组 - 通用寄存器、浮点寄存器等
│  └─ 栈指针 (SP) - 线程私有栈
│
├─ 线程调度信息
│  ├─ 线程状态 (就绪/运行/阻塞)
│  ├─ 优先级
│  ├─ 调度策略
│  └─ CPU亲和性
│
└─ 线程私有存储
   ├─ 线程栈（独立的栈空间）
   ├─ 线程局部存储 (TLS)
   └─ 错误码 (errno)
```

**关键点**：
- TCB 只关注"怎么执行"
- 线程栈是独立的，用于函数调用
- 其他资源（内存、文件等）从所属进程的 PCB 获取

### 进程与线程的数据结构关系

```
进程 PCB
├─ 共享资源区域（所有线程共享）
│  ├─ 内存映射（页表）
│  ├─ 文件描述符
│  ├─ 信号处理
│  └─ 工作目录
│
└─ 线程列表
   ├─ TCB 1 (主线程)
   │  ├─ PC, 寄存器, SP
   │  └─ 线程栈
   │
   ├─ TCB 2
   │  ├─ PC, 寄存器, SP
   │  └─ 线程栈
   │
   └─ TCB n
      ├─ PC, 寄存器, SP
      └─ 线程栈
```

## 进程切换步骤

进程切换（Context Switch）是一个复杂且开销大的操作。

### 完整步骤：

#### 1. 保存当前进程的状态
```
将 CPU 寄存器状态保存到当前进程的 PCB：
├─ 保存程序计数器 (PC)
├─ 保存通用寄存器 (R0-R15 等)
├─ 保存栈指针 (SP)
├─ 保存程序状态字 (PSW)
└─ 保存浮点寄存器（如果使用）
```

#### 2. 更新当前进程的状态信息
```
├─ 将进程状态从"运行"改为"就绪"或"阻塞"
├─ 更新 CPU 使用时间统计
└─ 将进程放入相应的调度队列
```

#### 3. 选择下一个要运行的进程
```
├─ 调度算法选择下一个进程（如优先级、时间片轮转）
├─ 从就绪队列中取出目标进程
└─ 将目标进程状态改为"运行"
```

#### 4. 切换内存地址空间（关键且昂贵）
```
├─ 保存当前进程的页表基址寄存器
├─ 加载新进程的页表基址寄存器
├─ 刷新 TLB (Translation Lookaside Buffer)
└─ 清空流水线和缓存（可能需要）
```

#### 5. 恢复新进程的状态
```
从新进程的 PCB 恢复：
├─ 恢复程序计数器 (PC)
├─ 恢复通用寄存器
├─ 恢复栈指针 (SP)
├─ 恢复程序状态字 (PSW)
└─ 恢复浮点寄存器
```

#### 6. 跳转到新进程继续执行
```
└─ CPU 从新的 PC 位置开始执行指令
```

### 开销分析：

**主要开销来源**：
1. **切换地址空间** - 最昂贵
   - 修改页表基址寄存器
   - 刷新 TLB（所有地址映射缓存失效）
   - 可能刷新 CPU 缓存（L1/L2/L3 Cache）

2. **保存/恢复寄存器** - 中等
   - 几十个寄存器需要保存和恢复

3. **调度算法** - 较小
   - 选择下一个进程

**典型耗时**：几微秒到几十微秒

## 线程切换步骤

线程切换比进程切换简单得多。

### 同一进程内的线程切换：

#### 1. 保存当前线程的状态
```
将 CPU 寄存器状态保存到当前线程的 TCB：
├─ 保存程序计数器 (PC)
├─ 保存通用寄存器
├─ 保存栈指针 (SP)
└─ 保存程序状态字 (PSW)
```

#### 2. 更新当前线程的状态信息
```
├─ 将线程状态从"运行"改为"就绪"或"阻塞"
└─ 将线程放入调度队列
```

#### 3. 选择下一个要运行的线程
```
├─ 调度算法选择下一个线程
├─ 从就绪队列中取出目标线程
└─ 将目标线程状态改为"运行"
```

#### 4. 检查是否同一进程
```
if (新线程 in 同一进程) {
    ✓ 跳过地址空间切换（关键优化！）
    ✓ 页表不变
    ✓ TLB 不刷新
    ✓ CPU 缓存大部分有效
}
```

#### 5. 恢复新线程的状态
```
从新线程的 TCB 恢复：
├─ 恢复程序计数器 (PC)
├─ 恢复通用寄存器
├─ 恢复栈指针 (SP) - 切换到新线程的栈
└─ 恢复程序状态字 (PSW)
```

#### 6. 跳转到新线程继续执行
```
└─ CPU 从新的 PC 位置开始执行指令
```

### 不同进程的线程切换：

如果切换到不同进程的线程：
```
步骤 1-3：同上
步骤 4：需要切换地址空间（类似进程切换）
步骤 5-6：同上
```

### 开销分析：

**同进程内线程切换**（最常见）：
- ✓ 只需保存/恢复寄存器
- ✓ 不需要切换地址空间
- ✓ TLB 和缓存仍然有效
- **典型耗时**：几百纳秒到几微秒

**跨进程线程切换**：
- 与进程切换开销相同

## 为什么线程切换更快？

### 核心原因：避免地址空间切换

```
进程切换：
保存状态 → 切换页表 → 刷新TLB → 刷新缓存 → 恢复状态
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
           这部分开销占 70-80%

线程切换（同进程）：
保存状态 → [跳过] → 恢复状态
           快 10-100 倍！
```

### 具体时间对比

| 操作 | 典型耗时 | 说明 |
|------|---------|------|
| 寄存器保存/恢复 | ~100 ns | 快速内存访问 |
| 线程切换（同进程） | ~1 μs | 只有寄存器操作 |
| TLB 刷新 | ~10-50 μs | 清空地址映射缓存 |
| 进程切换 | ~10-100 μs | 包含地址空间切换 |

**1 微秒 (μs) = 1000 纳秒 (ns)**

## 内存布局对比

### 单进程单线程
```
进程地址空间：
├─ 代码段 (Text)
├─ 数据段 (Data)
├─ 堆 (Heap) ↑ 向上增长
│   ...
├─ 栈 (Stack) ↓ 向下增长
└─ 内核空间
```

### 单进程多线程
```
进程地址空间：
├─ 代码段 (Text)          ← 所有线程共享
├─ 数据段 (Data)          ← 所有线程共享
├─ 堆 (Heap) ↑            ← 所有线程共享
│   ...
├─ 线程1栈 ↓              ← 线程1独有
├─ 线程2栈 ↓              ← 线程2独有
├─ 线程3栈 ↓              ← 线程3独有
└─ 内核空间
```

### 多进程
```
进程1地址空间：          进程2地址空间：
├─ 代码段               ├─ 代码段
├─ 数据段               ├─ 数据段
├─ 堆                   ├─ 堆
├─ 栈                   ├─ 栈
└─ 内核空间             └─ 内核空间

完全隔离，通过页表映射到不同的物理内存
```

## 实际应用场景

### 使用进程的场景
- 需要强隔离性（浏览器的不同标签页）
- 避免互相影响（一个崩溃不影响其他）
- 利用多核CPU（多个进程分配到不同核心）
- 分布式系统（微服务架构）

### 使用线程的场景
- 需要频繁通信（共享内存更快）
- 资源受限（线程更轻量）
- 并发I/O操作（网络服务器）
- GUI应用（主线程处理界面，工作线程处理任务）

## 总结

**进程 = 资源的容器**
- 数据结构：PCB（进程控制块）
- 包含：内存映射、文件、信号等
- 切换开销大：需要切换地址空间

**线程 = CPU执行的单元**
- 数据结构：TCB（线程控制块）
- 包含：PC、寄存器、栈
- 切换开销小：同进程内无需切换地址空间

**关键洞察**：
- CPU 真正执行的是线程
- 线程切换快是因为避免了昂贵的地址空间切换
- 进程提供隔离，线程提供并发
