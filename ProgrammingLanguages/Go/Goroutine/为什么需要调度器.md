# 从进程到 Goroutine：调度器的进化史

## 为什么需要调度器？一个本质问题

**核心矛盾**：
```
计算资源有限（CPU核心数）
    vs
计算任务众多（成百上千个任务）
```

**调度器的使命**：
> 让有限的 CPU 核心高效地执行众多的计算任务

---

## 第一阶段：单任务时代（1950s）- 没有调度器

### 场景
```
计算机房：
├─ 一台巨型计算机
├─ 一次只能运行一个程序
└─ 程序员排队使用
```

### 问题

**例子**：一个计算任务
```
程序运行：
1. CPU 计算 (10ms)
2. 等待磁盘读取 (100ms) ← CPU 空闲！
3. CPU 计算 (10ms)
4. 等待打印 (1000ms)  ← CPU 空闲！
```

**CPU 利用率**：20ms / 1120ms ≈ **1.8%**

### 问题本质
- CPU 等待 I/O 时完全空闲
- 昂贵的计算资源被严重浪费

---

## 第二阶段：多道程序与进程（1960s）- OS 调度器诞生

### 解决方案：让 CPU 忙起来

**多道程序系统**：
```
内存中同时加载多个程序：
├─ 程序 A - 正在执行
├─ 程序 B - 等待 I/O
├─ 程序 C - 等待 I/O
└─ 程序 D - 就绪

当 A 等待 I/O 时 → 切换到 D 执行
```

### 进程调度器（OS Scheduler）出现

**职责**：
1. **时间片轮转**：每个进程执行一段时间
2. **I/O 等待**：进程等待 I/O 时切换
3. **优先级调度**：重要任务优先

**数据结构**：
```
就绪队列：[进程A] → [进程B] → [进程C]
阻塞队列：[进程D 等待磁盘] [进程E 等待网络]

OS 调度器：
while (true) {
    进程 = 从就绪队列选择一个
    恢复进程的寄存器
    切换到进程的地址空间
    执行进程一个时间片
    保存进程的寄存器
}
```

### 成果
- CPU 利用率提升到 60-80%
- 多个用户可以"同时"使用计算机

### 代价
**进程切换开销大**：
```
进程切换步骤：
1. 保存寄存器         (~100ns)
2. 切换页表           (~1μs)
3. 刷新 TLB           (~10μs)
4. 刷新 CPU 缓存      (~50μs)
5. 恢复寄存器         (~100ns)
────────────────────────────
总计：~60μs
```

**但可以接受**：
- 进程通常运行较长时间（几十毫秒）
- 切换开销占比小（60μs / 10ms = 0.6%）

---

## 第三阶段：线程时代（1980s-1990s）- 更细粒度的调度

### 新的需求：进程内并发

**例子**：文字处理软件
```
单进程时代：
主循环 {
    处理键盘输入
    拼写检查
    自动保存
    打印
}
→ 所有任务串行，打印时界面卡死
```

**需求**：
- 界面响应（主线程）
- 后台拼写检查（工作线程）
- 自动保存（工作线程）
- 打印（工作线程）

### 线程：进程内的调度单元

**方案**：在进程内创建多个线程
```
文字处理进程：
├─ 线程1：处理界面（主线程）
├─ 线程2：拼写检查
├─ 线程3：自动保存
└─ 线程4：打印

共享：
├─ 文档数据
├─ 文件句柄
└─ 内存空间
```

### OS 调度器升级：调度线程

```
之前：调度进程
现在：调度线程

就绪队列：
[进程A-线程1] → [进程B-线程1] → [进程A-线程2] → [进程C-线程1]
```

### 线程切换的优势

**同进程内线程切换**：
```
线程切换步骤：
1. 保存寄存器         (~100ns)
2. 无需切换页表       (0) ✓
3. 无需刷新 TLB       (0) ✓
4. 缓存大部分仍有效   (0) ✓
5. 恢复寄存器         (~100ns)
────────────────────────────
总计：~1μs (快 60 倍！)
```

### 成果
- 程序可以更好地利用多核 CPU
- 响应性更好（界面不卡顿）
- 共享内存通信简单

### 新的问题出现

**问题 1：线程创建仍然很重**
```
创建一个线程：
├─ 系统调用（用户态→内核态）
├─ 分配内核栈 (几 KB)
├─ 初始化 TCB
├─ 分配线程 ID
└─ 返回用户态

耗时：~10-100μs
```

**问题 2：线程数量有限**
```
操作系统限制：
├─ Linux: 几千到几万个线程
├─ 每个线程栈：1-2 MB
└─ 10,000 个线程 = 10-20 GB 内存仅用于栈！
```

**问题 3：OS 调度开销**
```
每次线程切换：
├─ 用户态 → 内核态（系统调用）
├─ 内核调度器选择线程
└─ 内核态 → 用户态

即使同进程内切换，仍需进入内核
```

### 问题场景：C10K 问题

**2000年代初的挑战**：
```
Web 服务器需要处理 10,000 个并发连接

传统做法：每个连接一个线程
├─ 10,000 个线程
├─ 20 GB 内存用于栈
├─ 频繁的上下文切换
└─ 性能崩溃
```

**困境**：
- 需要大量并发任务（成千上万）
- OS 线程太重（无法创建这么多）
- OS 调度开销大（频繁进入内核）

---

## 第四阶段：用户态调度器（2000s-现在）- Goroutine 时代

### 核心思想：把调度器搬到用户态

**设计理念**：
```
OS 线程是有限且昂贵的资源
    ↓
我们自己在用户态实现一个调度器
    ↓
在少量 OS 线程上运行大量"轻量级线程"
```

### Go 的方案：GMP 调度器

**架构**：
```
用户态（Go Runtime）：
├─ Goroutine 调度器
├─ 10,000 个 Goroutine (轻量级)
└─ 调度到 ↓

OS 内核态：
└─ 8 个 OS 线程 (数量 = CPU 核心数)
```

### 为什么需要用户态调度器？

#### 理由 1：降低创建成本

**对比**：
```
创建 OS 线程：
├─ 系统调用
├─ 分配 1-2 MB 栈
├─ 内核初始化 TCB
└─ 耗时：~10-100μs

创建 Goroutine：
├─ 用户态函数调用（无系统调用）
├─ 分配 2 KB 栈（按需增长）
├─ Go Runtime 初始化 g 结构
└─ 耗时：~1μs

快 10-100 倍！
```

#### 理由 2：降低切换成本

**对比**：
```
OS 线程切换（跨进程）：
├─ 用户态 → 内核态
├─ 内核调度器选择
├─ 切换地址空间（如果跨进程）
├─ 内核态 → 用户态
└─ 耗时：~1-10μs

Goroutine 切换（用户态）：
├─ 保存当前 G 的寄存器
├─ Go 调度器选择下一个 G
├─ 恢复下一个 G 的寄存器
└─ 耗时：~200ns

快 5-50 倍！
```

#### 理由 3：支持海量并发

**对比**：
```
OS 线程：
├─ 最多：几千到几万个
├─ 每个栈：1-2 MB
└─ 内存限制

Goroutine：
├─ 最多：几十万到几百万个
├─ 初始栈：2 KB（可增长）
└─ 相同内存可创建 500-1000 倍的 Goroutine
```

**示例**：
```
100,000 个并发任务：

使用 OS 线程：
100,000 * 1 MB = 100 GB 内存 ✗

使用 Goroutine：
100,000 * 2 KB = 200 MB 内存 ✓
```

#### 理由 4：更好的调度策略

**OS 调度器的局限**：
```
OS 不理解你的程序逻辑：
├─ 只能基于时间片、优先级
├─ 不知道哪些线程会频繁协作
└─ 可能把相关线程调度到不同核心（缓存失效）
```

**Go 调度器的优势**：
```
Go Runtime 理解你的程序：
├─ 知道 Goroutine 间的依赖（channel）
├─ 可以优先调度准备好的 Goroutine
├─ 可以基于工作窃取实现负载均衡
└─ 可以识别并处理阻塞（系统调用、channel）
```

### Go 调度器的工作原理

#### M:N 调度模型

```
M 个 Goroutine 映射到 N 个 OS 线程

100,000 Goroutine
    ↓ (Go 调度器)
8 个 OS 线程
    ↓ (OS 调度器)
4 个 CPU 核心
```

#### GMP 架构

```
G (Goroutine)：
├─ 用户代码的执行单元
├─ 2 KB 初始栈
└─ 保存的寄存器状态

M (Machine - OS 线程)：
├─ 真正的 OS 线程
├─ 执行 Goroutine
└─ 数量动态调整（通常等于 CPU 核心数）

P (Processor - 逻辑处理器)：
├─ 调度的上下文
├─ 本地 Goroutine 队列（256 个）
├─ M 必须绑定 P 才能执行 G
└─ 数量 = GOMAXPROCS（默认等于 CPU 核心数）
```

#### 调度流程

```
1. 创建 Goroutine
   go func() { ... }
      ↓
   放入 P 的本地队列

2. M 从 P 获取 G
   M1-P1: [G1 G2 G3 G4]
      ↓
   M1 获取 G1 执行

3. G1 阻塞（如等待 channel）
      ↓
   M1 从 P1 获取 G2 继续执行

4. P1 的队列空了
      ↓
   从全局队列获取
   或从其他 P 窃取（Work Stealing）

5. M1 执行系统调用（如读文件）
      ↓
   P1 从 M1 分离
   寻找新的 M2（或创建）
   M2 绑定 P1，继续执行其他 G
```

### 用户态调度的关键技术

#### 1. 栈管理：动态增长的栈

```
OS 线程栈：
├─ 固定大小：1-2 MB
├─ 预分配（浪费内存）
└─ 溢出会崩溃

Goroutine 栈：
├─ 初始：2 KB
├─ 动态增长（按需分配）
├─ 最大：1 GB（64位系统）
└─ 节省内存
```

**实现**：
```
函数调用时检查：
if 栈空间不足 {
    分配更大的栈
    复制旧栈内容
    调整指针
    释放旧栈
}
```

#### 2. 快速上下文切换

**无需系统调用**：
```
OS 线程切换：
用户态 → [系统调用] → 内核态 → [调度] → 内核态 → [返回] → 用户态

Goroutine 切换：
用户态 → [Go Runtime] → 用户态
（全程在用户态！）
```

**保存/恢复更少的状态**：
```go
// Go 只需保存几个寄存器
type gobuf struct {
    sp   uintptr  // 栈指针
    pc   uintptr  // 程序计数器
    g    *g       // goroutine 指针
    ret  uintptr  // 返回值
    // ... 其他几个寄存器
}
```

#### 3. 工作窃取（Work Stealing）

**负载均衡**：
```
P1: [G1 G2 G3 G4 G5 G6 G7 G8] - 很多任务
P2: [G9]                       - 快完成了
P3: []                         - 空闲
P4: [G10 G11]                  - 较少任务

P3 空闲时：
1. 检查全局队列
2. 随机选择一个 P（如 P1）
3. 窃取一半的 G（G5 G6 G7 G8）
4. 开始执行
```

**优势**：
- 自动负载均衡
- 减少全局队列竞争

#### 4. 处理阻塞：P/M 分离

**问题**：Goroutine 执行系统调用会阻塞 OS 线程

**解决**：
```
G1 在 M1 上执行系统调用（阻塞）
    ↓
P1 从 M1 分离
    ↓
P1 寻找空闲的 M2（或创建新的）
    ↓
M2 绑定 P1，继续执行其他 Goroutine
    ↓
M1 在后台等待系统调用返回
    ↓
系统调用返回后，M1 尝试获取 P
    ↓
如果获取到 P，继续执行 G1
否则，G1 放入全局队列
```

**效果**：
- P（调度上下文）不会被阻塞
- CPU 保持忙碌

#### 5. 协作式 + 抢占式调度

**早期（Go 1.14 之前）- 协作式**：
```
Goroutine 在这些时机让出 CPU：
├─ 函数调用（栈检查）
├─ channel 操作
├─ 系统调用
└─ 垃圾回收

问题：死循环无法被抢占
for {
    // 无函数调用，永远占用 CPU
}
```

**现代（Go 1.14+）- 异步抢占**：
```
Sysmon 监控线程：
├─ 检测运行超过 10ms 的 Goroutine
├─ 发送抢占信号（SIGURG）
└─ 信号处理器暂停 Goroutine，切换到调度器

效果：即使死循环也能被抢占
```

---

## 完整的进化历程总结

### 时间线

```
1950s: 单任务
       ├─ 问题：CPU 利用率低
       └─ 没有调度器

1960s: 进程 + OS 调度器
       ├─ 解决：提高 CPU 利用率
       ├─ 问题：进程切换开销大
       └─ 调度单位：进程

1980s: 线程 + OS 线程调度
       ├─ 解决：进程内并发，切换更快
       ├─ 问题：线程仍然重，数量受限
       └─ 调度单位：线程

2000s: 用户态调度器 + 协程/Goroutine
       ├─ 解决：海量并发，极低开销
       ├─ 创新：两级调度（用户态 + 内核态）
       └─ 调度单位：Goroutine
```

### 为什么每个阶段都需要新的调度器？

| 时代 | 调度器 | 解决的问题 | 调度单位 | 创建开销 | 切换开销 | 数量限制 |
|------|--------|-----------|---------|---------|---------|---------|
| 1950s | 无 | 无 | 程序 | - | - | 1 |
| 1960s | OS进程调度 | CPU利用率低 | 进程 | ~1ms | ~60μs | 几百 |
| 1980s | OS线程调度 | 进程内并发 | 线程 | ~50μs | ~1μs | 几千 |
| 2000s | 用户态调度 | 海量并发 | Goroutine | ~1μs | ~200ns | 几十万 |

### 调度器进化的驱动力

```
硬件发展：
单核 → 多核 → 众核
   ↓      ↓      ↓
需求变化：
计算密集 → I/O密集 → 海量并发
   ↓      ↓      ↓
软件对策：
单任务 → 多线程 → 协程/Goroutine
```

### 本质规律

**调度器的三大目标**（不可能三角）：
```
      低开销
      /    \
     /      \
    /        \
高并发 ←→ 公平性
```

不同时代的权衡：
- **进程调度器**：牺牲并发数，保证隔离和公平
- **线程调度器**：牺牲一定开销，提升并发
- **用户态调度器**：牺牲一定公平性（用户态实现），极致的低开销和高并发

---

## Go 调度器的现代意义

### 1. 适应现代应用模式

**现代服务的特点**：
```
传统应用：
├─ 计算密集
├─ 少量长期任务
└─ 适合 OS 线程

现代应用（微服务、云原生）：
├─ I/O 密集（网络、数据库）
├─ 海量短期任务
├─ 需要极高的并发
└─ 适合 Goroutine
```

### 2. 简化并发编程

**程序员视角**：
```
OS 线程：
├─ 需要考虑线程池
├─ 需要管理线程数量
├─ 需要手动同步
└─ 复杂

Goroutine：
├─ 随意创建（go func()）
├─ 不用担心数量
├─ channel 简化同步
└─ 简单
```

### 3. 提升资源利用率

**效果**：
```
8 核机器：

使用 OS 线程：
├─ 创建 8-16 个线程
├─ 线程阻塞时 CPU 空闲
└─ CPU 利用率：30-50%

使用 Goroutine：
├─ 创建 100,000 个 Goroutine
├─ 调度到 8 个 OS 线程
├─ Goroutine 阻塞时立即切换
└─ CPU 利用率：80-95%
```

---

## 总结：为什么需要调度器？

### 答案的三个层次

**第一层（功能层）**：
调度器让有限的 CPU 核心执行众多的任务

**第二层（效率层）**：
调度器通过快速切换来提高 CPU 利用率和响应性

**第三层（进化层）**：
随着硬件和需求的演变，调度器不断进化以适应新的挑战
- 进程调度器 → 解决 CPU 空闲问题
- 线程调度器 → 解决进程太重问题
- 用户态调度器 → 解决线程数量受限、切换开销大的问题

### Go 调度器存在的必然性

```
问题：现代应用需要海量并发（10万+）
   ↓
OS 线程无法满足（数量限制、开销大）
   ↓
必须：在用户态实现轻量级调度
   ↓
方案：Goroutine + GMP 调度器
```

**Go 调度器不是"锦上添花"，而是"必不可少"**：
- 没有它，就无法创建海量 Goroutine
- 没有它，就无法高效利用多核 CPU
- 没有它，Go 的并发模型就无法成立

调度器是 Go 语言核心竞争力的基石！
